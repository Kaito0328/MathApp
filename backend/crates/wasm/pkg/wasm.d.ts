/* tslint:disable */
/* eslint-disable */
export function window_hann(size: number): Float64Array;
export function window_hamming(size: number): Float64Array;
export function window_blackman(size: number): Float64Array;
export function window_rectangular(size: number): Float64Array;
export function window_kaiser(size: number, beta: number): Float64Array;
export function sp_design_fir_lowpass(num_taps: number, normalized_cutoff: number): Float64Array;
export function sp_design_fir_highpass(num_taps: number, normalized_cutoff: number): Float64Array;
export function sp_design_fir_bandpass(num_taps: number, f1: number, f2: number): Float64Array;
export function sp_design_fir_bandstop(num_taps: number, f1: number, f2: number): Float64Array;
export function sp_design_iir_butter_lowpass(order: number, fs: number, fc_hz: number): DiscreteTF;
export function sp_design_iir_butter_highpass(order: number, fs: number, fc_hz: number): DiscreteTF;
export function sp_design_iir_butter_bandpass(order: number, fs: number, f1_hz: number, f2_hz: number): DiscreteTF;
export function sp_design_iir_butter_bandstop(order: number, fs: number, f1_hz: number, f2_hz: number): DiscreteTF;
export function sp_design_iir_cheby1_lowpass(order: number, ripple_db: number, fs: number, fc_hz: number): DiscreteTF;
export function sp_design_iir_cheby2_lowpass(order: number, stop_atten_db: number, fs: number, fc_hz: number): DiscreteTF;
export function img_convolve2d_f32_simple(src: Float64Array, width: number, height: number, kernel: Float64Array, kw: number, kh: number, border: WasmBorder): Float64Array;
export function img_convolve2d_f32(src: Float64Array, width: number, height: number, kernel: Float64Array, kw: number, kh: number, border: WasmBorder): Float64Array;
export function img_convolve2d_u8(src: Uint8Array, width: number, height: number, kernel: Float64Array, kw: number, kh: number, border: WasmBorder): Uint8Array;
export function img_dft2d(src: Float64Array, width: number, height: number): Float64Array;
export function img_idft2d(spec_interleaved: Float64Array, width: number, height: number): Float64Array;
export function img_fftshift(spec_interleaved: Float64Array, width: number, height: number): Float64Array;
export function img_magnitude(spec_interleaved: Float64Array, width: number, height: number): Float64Array;
export function img_gaussian_blur_f32(src: Float64Array, width: number, height: number, sigma: number, radius: number, border: WasmBorder): Float64Array;
export function img_gaussian_blur_u8(src: Uint8Array, width: number, height: number, sigma: number, radius: number, border: WasmBorder): Uint8Array;
export function img_box_filter_f32(src: Float64Array, width: number, height: number, radius: number, border: WasmBorder): Float64Array;
export function img_box_filter_u8(src: Uint8Array, width: number, height: number, radius: number, border: WasmBorder): Uint8Array;
export function img_unsharp_mask_f32(src: Float64Array, width: number, height: number, sigma: number, radius: number, amount: number, border: WasmBorder): Float64Array;
export function img_unsharp_mask_u8(src: Uint8Array, width: number, height: number, sigma: number, radius: number, amount: number, border: WasmBorder): Uint8Array;
export function img_sobel_magnitude_f32(src: Float64Array, width: number, height: number, border: WasmBorder): Float64Array;
export function img_sobel_magnitude_u8(src: Uint8Array, width: number, height: number, border: WasmBorder): Uint8Array;
export function img_laplacian_f32(src: Float64Array, width: number, height: number, border: WasmBorder): Float64Array;
export function img_laplacian_u8(src: Uint8Array, width: number, height: number, border: WasmBorder): Uint8Array;
export function img_median_filter_f32(src: Float64Array, width: number, height: number, radius: number, border: WasmBorder): Float64Array;
export function img_median_filter_u8(src: Uint8Array, width: number, height: number, radius: number, border: WasmBorder): Uint8Array;
export function img_bilateral_filter_f32(src: Float64Array, width: number, height: number, radius: number, sigma_s: number, sigma_r: number, border: WasmBorder): Float64Array;
export function img_bilateral_filter_u8(src: Uint8Array, width: number, height: number, radius: number, sigma_s: number, sigma_r: number, border: WasmBorder): Uint8Array;
export function rgb_u8_to_gray_f64(rgb: Uint8Array, width: number, height: number): Float64Array;
export function rgba_u8_to_gray_f64(rgba: Uint8Array, width: number, height: number): Float64Array;
export function gray_f64_to_rgba_u8(gray: Float64Array, width: number, height: number): Uint8Array;
export function u8_to_gray_f64(pixels: Uint8Array): Float64Array;
export function gray_f64_to_u8_clamped(gray: Float64Array): Uint8Array;
export function img_convolve2d_f32_io(src: Float32Array, width: number, height: number, kernel: Float32Array, kw: number, kh: number, border: WasmBorder): Float32Array;
export function img_gaussian_blur_f32_io(src: Float32Array, width: number, height: number, sigma: number, radius: number, border: WasmBorder): Float32Array;
export function init(): void;
export function __probe(): number;
export function solveLinearSystem(rows: number, cols: number, a_data: Float64Array, b: Float64Array): Float64Array;
export function ridgeRegression(rows: number, cols: number, a_data: Float64Array, b: Float64Array, alpha: number): Float64Array;
export function lassoRegression(rows: number, cols: number, a_data: Float64Array, b: Float64Array, alpha: number, max_iter: number, tol: number): Float64Array;
export function logisticFit(rows: number, cols: number, x_data: Float64Array, y: Float64Array, lr: number, max_iter: number): Float64Array;
export function logisticPredictProba(cols: number, coeffs: Float64Array, x: Float64Array): number;
export function gmmFit(n_samples: number, n_features: number, data: Float64Array, k: number, max_iter: number, tol: number): Float64Array;
export function gmmPredictProba(n_features: number, params: Float64Array, x: Float64Array): Float64Array;
export function bayesianLinearPosterior(rows: number, cols: number, x_data: Float64Array, y: Float64Array, prior_mean: Float64Array, prior_cov: Float64Array, noise_cov: Float64Array): Float64Array;
export function kalmanPredict(n: number, f_flat: Float64Array, q_flat: Float64Array, x_flat: Float64Array, p_flat: Float64Array): Float64Array;
export function kalmanUpdate(n: number, h_flat: Float64Array, r_flat: Float64Array, z_flat: Float64Array, x_flat: Float64Array, p_flat: Float64Array): Float64Array;
export function convolveNaiveF64(x: Float64Array, h: Float64Array): Float64Array;
export function convolveFftF64(x: Float64Array, h: Float64Array): Float64Array;
export function convolveAutoF64(x: Float64Array, h: Float64Array, threshold: number): Float64Array;
export function defaultConvolutionThreshold(): number;
export function dftComplexF64(x_flat: Float64Array): Float64Array;
export function iftComplexF64(x_flat: Float64Array): Float64Array;
export function binom(n: number, k: number): number;
export function stirling2(n: number, k: number): number;
export function fallingFactorialPoly(m: number): Float64Array;
export function risingFactorialPoly(m: number): Float64Array;
export function shiftPolyXPlusH(coeffs_flat: Float64Array, h: number): Float64Array;
export function discreteDiff(coeffs_flat: Float64Array): Float64Array;
export function discreteSum(coeffs_flat: Float64Array): Float64Array;
export function solveRecurrence(coeffs: Float64Array, nh_polys_flat: Float64Array, nh_offsets: Uint32Array, nh_bases: Float64Array, initial_values: Float64Array): ClosedForm;
export function hammingDistanceGF2(a: Uint8Array, b: Uint8Array): number;
export function weightDistributionGF2(codebook_flat: Uint8Array, n: number): Uint32Array;
export function nt_factor_u64(n: bigint): BigUint64Array;
export function nt_factor_bigint_str(n_str: string): string[];
export function erf(x: number): number;
export function erfc(x: number): number;
export function erfInv(y: number): number;
export function gamma(x: number): number;
export function logGamma(x: number): number;
export function regularizedGamma(s: number, x: number): number;
export function beta(a: number, b: number): number;
export function logBeta(a: number, b: number): number;
export function regularizedBeta(a: number, b: number, x: number): number;
export enum WasmBorder {
  ConstantZero = 0,
  Replicate = 1,
  Reflect = 2,
}
export class BCH {
  free(): void;
  constructor(n: number, g: Uint8Array);
  encode(u: Uint8Array): Uint8Array;
  k(): number;
  n(): number;
  t(): number;
}
export class Bernoulli {
  free(): void;
  constructor(p: number);
  mean(): number;
  variance(): number;
  std_dev(): number;
  pmf(k: number): number;
  cdf(k: number): number;
  quantile(p: number): number;
  pmf_svg(width: number, height: number): string;
}
export class Binomial {
  free(): void;
  constructor(n: number, p: number);
  mean(): number;
  variance(): number;
  std_dev(): number;
  pmf(k: number): number;
  cdf(k: number): number;
  quantile(p: number): number;
  pmf_svg(width: number, height: number): string;
}
export class Categorical {
  free(): void;
  constructor(probs: Float64Array);
  pmf(k: number): number;
  log_pmf(k: number): number;
  cdf(k: number): number;
  quantile(p: number): number;
  pmf_svg(width: number, height: number): string;
}
export class ChiSquare {
  free(): void;
  constructor(k: number);
  mean(): number;
  variance(): number;
  std_dev(): number;
  pdf(x: number): number;
  cdf(x: number): number;
  quantile(p: number): number;
  pdf_svg(width: number, height: number, samples: number): string;
}
export class ClosedForm {
  private constructor();
  free(): void;
  termsCount(): number;
  termPoly(i: number): Float64Array;
  termBase(i: number): Float64Array;
  term(n: number): Float64Array;
}
export class ContinuousSS {
  private constructor();
  free(): void;
}
export class ContinuousTF {
  private constructor();
  free(): void;
}
export class ContinuousZpk {
  private constructor();
  free(): void;
}
export class CyclicCode {
  free(): void;
  constructor(n: number, g: Uint8Array);
  encode(u: Uint8Array): Uint8Array;
  k(): number;
}
export class DiscreteSS {
  private constructor();
  free(): void;
}
export class DiscreteTF {
  private constructor();
  free(): void;
}
export class DiscreteZpk {
  private constructor();
  free(): void;
}
export class Exponential {
  free(): void;
  constructor(lambda: number);
  mean(): number;
  variance(): number;
  std_dev(): number;
  pdf(x: number): number;
  cdf(x: number): number;
  quantile(p: number): number;
  pdf_svg(width: number, height: number, samples: number): string;
}
export class F {
  free(): void;
  constructor(d1: number, d2: number);
  mean(): number;
  variance(): number;
  std_dev(): number;
  pdf(x: number): number;
  cdf(x: number): number;
  quantile(p: number): number;
  pdf_svg(width: number, height: number, samples: number): string;
}
export class GF2 {
  free(): void;
  constructor(value: bigint);
  static modulus(): number;
  inv(): GF2;
  static zero(): GF2;
  static one(): GF2;
  add(rhs: GF2): GF2;
  sub(rhs: GF2): GF2;
  mul(rhs: GF2): GF2;
  div(other: GF2): GF2;
  neg(): GF2;
  readonly value: bigint;
  readonly isZero: boolean;
  readonly isOne: boolean;
}
export class GF3 {
  free(): void;
  constructor(value: bigint);
  static modulus(): number;
  inv(): GF3;
  static zero(): GF3;
  static one(): GF3;
  add(rhs: GF3): GF3;
  sub(rhs: GF3): GF3;
  mul(rhs: GF3): GF3;
  div(other: GF3): GF3;
  neg(): GF3;
  readonly value: bigint;
  readonly isZero: boolean;
  readonly isOne: boolean;
}
export class GFExtGF2 {
  free(): void;
  constructor(px_coeffs: Uint8Array, coeffs: Uint8Array);
  static fromBase(px_coeffs: Uint8Array, base_value: number): GFExtGF2;
  inv(): GFExtGF2;
  static zero(): GFExtGF2;
  static one(): GFExtGF2;
  add(rhs: GFExtGF2): GFExtGF2;
  sub(rhs: GFExtGF2): GFExtGF2;
  mul(rhs: GFExtGF2): GFExtGF2;
  div(other: GFExtGF2): GFExtGF2;
  neg(): GFExtGF2;
  readonly coeffs: Uint8Array;
  readonly px: Uint8Array;
}
export class Gamma {
  free(): void;
  constructor(shape: number, rate: number);
  mean(): number;
  variance(): number;
  std_dev(): number;
  pdf(x: number): number;
  cdf(x: number): number;
  quantile(p: number): number;
  pdf_svg(width: number, height: number, samples: number): string;
}
export class Hamming74 {
  private constructor();
  free(): void;
}
export class LinearCode {
  free(): void;
  constructor(k: number, n: number, g_data: Uint8Array);
  encode(u: Uint8Array): Uint8Array;
}
export class Matrix {
  free(): void;
  constructor(rows: number, cols: number, data: Float64Array);
  static with_default(rows: number, cols: number): Matrix;
  static zeros(rows: number, cols: number): Matrix;
  static identity(size: number): Matrix;
  rows(): number;
  cols(): number;
  is_square(): boolean;
  transpose(): Matrix;
  trace(): number;
  determinant(): number;
  rank(): number;
  inverse(): Matrix | undefined;
  frobenius_norm(): number;
  expm(): Matrix;
  qr_decomposition(): any;
  svd(): any;
  eigen_decomposition(): any;
  cholesky(): Matrix;
  pinv(): Matrix;
}
export class MatrixF32 {
  free(): void;
  add(rhs: MatrixF32): MatrixF32;
  sub(rhs: MatrixF32): MatrixF32;
  mul(rhs: MatrixF32): MatrixF32;
  constructor(rows: number, cols: number, data: Float32Array);
  static with_default(rows: number, cols: number): MatrixF32;
  static zeros(rows: number, cols: number): MatrixF32;
  static identity(size: number): MatrixF32;
  rows(): number;
  cols(): number;
  is_square(): boolean;
  transpose(): MatrixF32;
  trace(): number;
  determinant(): number;
  rank(): number;
  inverse(): MatrixF32 | undefined;
}
export class MatrixF64 {
  free(): void;
  constructor(rows: number, cols: number, data: Float64Array);
  static with_default(rows: number, cols: number): MatrixF64;
  static zeros(rows: number, cols: number): MatrixF64;
  static identity(size: number): MatrixF64;
  rows(): number;
  cols(): number;
  is_square(): boolean;
  transpose(): MatrixF64;
  trace(): number;
  determinant(): number;
  rank(): number;
  inverse(): MatrixF64 | undefined;
  frobenius_norm(): number;
  expm(): MatrixF64;
  qr_decomposition(): any;
  svd(): any;
  eigen_decomposition(): any;
  cholesky(): MatrixF64;
  pinv(): MatrixF64;
  add(rhs: MatrixF64): MatrixF64;
  sub(rhs: MatrixF64): MatrixF64;
  mul(rhs: MatrixF64): MatrixF64;
  get(row: number, col: number): number;
  row(index: number): VectorF64 | undefined;
  col(index: number): VectorF64 | undefined;
  multiply_vector(vector: VectorF64): VectorF64 | undefined;
  diagonal(): VectorF64;
  solve(b: VectorF64): VectorF64 | undefined;
}
export class MatrixI32 {
  free(): void;
  add(rhs: MatrixI32): MatrixI32;
  sub(rhs: MatrixI32): MatrixI32;
  mul(rhs: MatrixI32): MatrixI32;
  constructor(rows: number, cols: number, data: Int32Array);
  static with_default(rows: number, cols: number): MatrixI32;
  static zeros(rows: number, cols: number): MatrixI32;
  static identity(size: number): MatrixI32;
  rows(): number;
  cols(): number;
  is_square(): boolean;
  transpose(): MatrixI32;
  trace(): number;
}
export class Normal {
  free(): void;
  constructor(mu: number, sigma: number);
  mean(): number;
  variance(): number;
  std_dev(): number;
  pdf(x: number): number;
  cdf(x: number): number;
  quantile(p: number): number;
  pdf_svg(width: number, height: number, samples: number): string;
}
export class Poisson {
  free(): void;
  constructor(lambda: number);
  mean(): number;
  variance(): number;
  std_dev(): number;
  pmf(k: number): number;
  log_pmf(k: number): number;
  cdf(k: number): number;
  quantile(p: number): number;
  pmf_svg(width: number, height: number): string;
}
export class PolynomialF64 {
  free(): void;
  add(rhs: PolynomialF64): PolynomialF64;
  sub(rhs: PolynomialF64): PolynomialF64;
  mul(rhs: PolynomialF64): PolynomialF64;
  div(rhs: PolynomialF64): PolynomialF64;
  divRem(other: PolynomialF64): PolynomialF64[];
  constructor(coeffs: Float64Array);
  deg(): number;
  get(i: number): number;
  eval(x: number): number;
}
export class PolynomialGF2 {
  free(): void;
  add(rhs: PolynomialGF2): PolynomialGF2;
  sub(rhs: PolynomialGF2): PolynomialGF2;
  mul(rhs: PolynomialGF2): PolynomialGF2;
  div(rhs: PolynomialGF2): PolynomialGF2;
  divRem(other: PolynomialGF2): PolynomialGF2[];
  constructor(coeffs: Uint8Array);
  deg(): number;
  get(i: number): number;
  eval(x: number): number;
}
export class PolynomialGF256 {
  free(): void;
  add(rhs: PolynomialGF256): PolynomialGF256;
  sub(rhs: PolynomialGF256): PolynomialGF256;
  mul(rhs: PolynomialGF256): PolynomialGF256;
  div(rhs: PolynomialGF256): PolynomialGF256;
  divRem(other: PolynomialGF256): PolynomialGF256[];
  constructor(coeffs: Uint8Array);
  deg(): number;
  get(i: number): number;
  eval(x: number): number;
}
export class PolynomialGFExtGF2 {
  free(): void;
  add(rhs: PolynomialGFExtGF2): PolynomialGFExtGF2;
  sub(rhs: PolynomialGFExtGF2): PolynomialGFExtGF2;
  mul(rhs: PolynomialGFExtGF2): PolynomialGFExtGF2;
  div(rhs: PolynomialGFExtGF2): PolynomialGFExtGF2;
  divRem(other: PolynomialGFExtGF2): PolynomialGFExtGF2[];
  constructor(px: Uint8Array, coeffs: Uint8Array[]);
  deg(): number;
  get(i: number): Uint8Array;
  eval(x_coeffs: Uint8Array): Uint8Array;
}
export class ReedSolomon {
  free(): void;
  constructor(k: number, alphas: Uint8Array);
  encode(f: Uint8Array): Uint8Array;
  decode(r: Uint8Array): Uint8Array;
  n(): number;
  t(): number;
}
export class StudentT {
  free(): void;
  constructor(df: number);
  mean(): number;
  variance(): number;
  std_dev(): number;
  pdf(x: number): number;
  cdf(x: number): number;
  quantile(p: number): number;
  pdf_svg(width: number, height: number, samples: number): string;
}
export class Uniform {
  free(): void;
  constructor(a: number, b: number);
  mean(): number;
  variance(): number;
  std_dev(): number;
  pdf(x: number): number;
  cdf(x: number): number;
  quantile(p: number): number;
  pdf_svg(width: number, height: number, samples: number): string;
}
export class Vector {
  free(): void;
  constructor(data: Float64Array);
  static zeros(dim: number): Vector;
  static ones(dim: number): Vector;
  dim(): number;
  len(): number;
  is_empty(): boolean;
  dot(other: Vector): number;
  argmax(): number | undefined;
  argmin(): number | undefined;
  max(): number | undefined;
  min(): number | undefined;
  norm(): number;
  normalize(): Vector;
  cosine_similarity(other: Vector): number;
  mean(): number | undefined;
  std(): number;
  static linspace(start: number, end: number, num: number): Vector;
  sum(): number;
  transpose(): MatrixF64;
  to_column_matrix(): MatrixF64;
  to_row_matrix(): MatrixF64;
}
export class VectorF32 {
  free(): void;
  add(rhs: VectorF32): VectorF32;
  sub(rhs: VectorF32): VectorF32;
  mul(rhs: VectorF32): VectorF32;
  constructor(data: Float32Array);
  static zeros(dim: number): VectorF32;
  static ones(dim: number): VectorF32;
  dim(): number;
  len(): number;
  is_empty(): boolean;
  dot(other: VectorF32): number;
  argmax(): number | undefined;
  argmin(): number | undefined;
  max(): number | undefined;
  min(): number | undefined;
}
export class VectorF64 {
  free(): void;
  constructor(data: Float64Array);
  static zeros(dim: number): VectorF64;
  static ones(dim: number): VectorF64;
  dim(): number;
  len(): number;
  is_empty(): boolean;
  dot(other: VectorF64): number;
  argmax(): number | undefined;
  argmin(): number | undefined;
  max(): number | undefined;
  min(): number | undefined;
  norm(): number;
  normalize(): VectorF64;
  cosine_similarity(other: VectorF64): number;
  mean(): number | undefined;
  std(): number;
  static linspace(start: number, end: number, num: number): VectorF64;
  add(rhs: VectorF64): VectorF64;
  sub(rhs: VectorF64): VectorF64;
  mul(rhs: VectorF64): VectorF64;
  sum(): number;
  multiply_matrix(matrix: MatrixF64): MatrixF64;
  transpose(): MatrixF64;
  to_column_matrix(): MatrixF64;
  to_row_matrix(): MatrixF64;
}
export class VectorI32 {
  free(): void;
  add(rhs: VectorI32): VectorI32;
  sub(rhs: VectorI32): VectorI32;
  mul(rhs: VectorI32): VectorI32;
  constructor(data: Int32Array);
  static zeros(dim: number): VectorI32;
  static ones(dim: number): VectorI32;
  dim(): number;
  len(): number;
  is_empty(): boolean;
  dot(other: VectorI32): number;
  argmax(): number | undefined;
  argmin(): number | undefined;
  max(): number | undefined;
  min(): number | undefined;
}
export class WasmGF2 {
  free(): void;
  constructor(value: bigint);
  static modulus(): number;
  inv(): WasmGF2;
  static zero(): WasmGF2;
  static one(): WasmGF2;
  add(rhs: WasmGF2): WasmGF2;
  sub(rhs: WasmGF2): WasmGF2;
  mul(rhs: WasmGF2): WasmGF2;
  div(other: WasmGF2): WasmGF2;
  neg(): WasmGF2;
  readonly value: bigint;
  readonly isZero: boolean;
  readonly isOne: boolean;
}
export class WasmGF256 {
  free(): void;
  toU8(): number;
  inv(): WasmGF256;
  static zero(): WasmGF256;
  static one(): WasmGF256;
  add(rhs: WasmGF256): WasmGF256;
  sub(rhs: WasmGF256): WasmGF256;
  mul(rhs: WasmGF256): WasmGF256;
  constructor(value: number);
  static fromCoeffs(coeffs: Uint8Array): WasmGF256;
  static modulus(): Uint8Array;
  div(other: WasmGF256): WasmGF256;
  neg(): WasmGF256;
  readonly isZero: boolean;
  readonly isOne: boolean;
  readonly value: number;
  readonly coeffs: Uint8Array;
}
export class WasmGF3 {
  free(): void;
  constructor(value: bigint);
  static modulus(): number;
  inv(): WasmGF3;
  static zero(): WasmGF3;
  static one(): WasmGF3;
  add(rhs: WasmGF3): WasmGF3;
  sub(rhs: WasmGF3): WasmGF3;
  mul(rhs: WasmGF3): WasmGF3;
  div(other: WasmGF3): WasmGF3;
  neg(): WasmGF3;
  readonly value: bigint;
  readonly isZero: boolean;
  readonly isOne: boolean;
}
export class WasmGFExtGF2 {
  free(): void;
  inv(): WasmGFExtGF2;
  static zero(): WasmGFExtGF2;
  static one(): WasmGFExtGF2;
  add(rhs: WasmGFExtGF2): WasmGFExtGF2;
  sub(rhs: WasmGFExtGF2): WasmGFExtGF2;
  mul(rhs: WasmGFExtGF2): WasmGFExtGF2;
  constructor(px_coeffs: Uint8Array, coeffs: Uint8Array);
  static fromBase(px_coeffs: Uint8Array, base_value: number): WasmGFExtGF2;
  div(other: WasmGFExtGF2): WasmGFExtGF2;
  neg(): WasmGFExtGF2;
  readonly isZero: boolean;
  readonly isOne: boolean;
  readonly coeffs: Uint8Array;
  readonly px: Uint8Array;
}
export class WasmLMS {
  free(): void;
  constructor(taps: number, step_size: number);
  process_sample(input: number, desired: number): Float64Array;
  process_series(input: Float64Array, desired: Float64Array): Float64Array;
}
export class WasmLinearModel {
  private constructor();
  free(): void;
  static solveLinearSystem(rows: number, cols: number, a_data: Float64Array, b: Float64Array): Float64Array;
  static ridgeRegression(rows: number, cols: number, a_data: Float64Array, b: Float64Array, alpha: number): Float64Array;
  static lassoRegression(rows: number, cols: number, a_data: Float64Array, b: Float64Array, alpha: number, max_iter: number, tol: number): Float64Array;
}
export class WasmNLMS {
  free(): void;
  constructor(taps: number, step_size: number, epsilon: number);
  process_sample(input: number, desired: number): Float64Array;
  process_series(input: Float64Array, desired: Float64Array): Float64Array;
}
export class WasmSignal {
  free(): void;
  constructor(data: Float64Array, sample_rate: number);
  data(): Float64Array;
  sample_rate(): number;
  len(): number;
  dft(): WasmSpectrum;
  convolve(h: WasmSignal): WasmSignal;
  apply_fir(taps: Float64Array): WasmSignal;
  downsample(factor: number, filter_taps: number): WasmSignal;
  upsample(factor: number, filter_taps: number): WasmSignal;
  resample(upsample_factor: number, downsample_factor: number, filter_taps: number): WasmSignal;
  decimate(factor: number): WasmSignal;
  expand(factor: number): WasmSignal;
  save_svg_simple(width: number, height: number): string;
  save_svg_with_axes(width: number, height: number, label?: string | null): string;
}
export class WasmSpectrum {
  free(): void;
  constructor(data_interleaved: Float64Array, sample_rate: number);
  data_interleaved(): Float64Array;
  sample_rate(): number;
  len(): number;
  ift(): WasmSignal;
  magnitude_db_svg(width: number, height: number, label?: string | null): string;
}

export type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;

export interface InitOutput {
  readonly memory: WebAssembly.Memory;
  readonly __wbg_matrixf64_free: (a: number, b: number) => void;
  readonly matrixf64_new: (a: number, b: number, c: number, d: number) => [number, number, number];
  readonly matrixf64_with_default: (a: number, b: number) => number;
  readonly matrixf64_zeros: (a: number, b: number) => number;
  readonly matrixf64_identity: (a: number) => number;
  readonly matrixf64_transpose: (a: number) => number;
  readonly matrixf64_trace: (a: number) => [number, number, number];
  readonly matrixf64_determinant: (a: number) => [number, number, number];
  readonly matrixf64_rank: (a: number) => [number, number, number];
  readonly matrixf64_inverse: (a: number) => number;
  readonly matrixf64_frobenius_norm: (a: number) => number;
  readonly matrixf64_expm: (a: number) => number;
  readonly matrixf64_qr_decomposition: (a: number) => [number, number, number];
  readonly matrixf64_svd: (a: number) => [number, number, number];
  readonly matrixf64_eigen_decomposition: (a: number) => [number, number, number];
  readonly matrixf64_cholesky: (a: number) => [number, number, number];
  readonly matrixf64_pinv: (a: number) => [number, number, number];
  readonly matrixf64_add: (a: number, b: number) => number;
  readonly matrixf64_sub: (a: number, b: number) => number;
  readonly matrixf64_mul: (a: number, b: number) => number;
  readonly __wbg_vectorf64_free: (a: number, b: number) => void;
  readonly vectorf64_new: (a: number, b: number) => number;
  readonly vectorf64_zeros: (a: number) => number;
  readonly vectorf64_ones: (a: number) => number;
  readonly vectorf64_dim: (a: number) => number;
  readonly vectorf64_is_empty: (a: number) => number;
  readonly vectorf64_dot: (a: number, b: number) => number;
  readonly vectorf64_argmax: (a: number) => number;
  readonly vectorf64_argmin: (a: number) => number;
  readonly vectorf64_max: (a: number) => [number, number];
  readonly vectorf64_min: (a: number) => [number, number];
  readonly vectorf64_norm: (a: number) => number;
  readonly vectorf64_normalize: (a: number) => number;
  readonly vectorf64_cosine_similarity: (a: number, b: number) => number;
  readonly vectorf64_mean: (a: number) => [number, number];
  readonly vectorf64_std: (a: number) => number;
  readonly vectorf64_linspace: (a: number, b: number, c: number) => [number, number, number];
  readonly vectorf64_add: (a: number, b: number) => number;
  readonly vectorf64_sub: (a: number, b: number) => number;
  readonly vectorf64_mul: (a: number, b: number) => number;
  readonly vectorf64_sum: (a: number) => number;
  readonly vectorf64_multiply_matrix: (a: number, b: number) => [number, number, number];
  readonly matrixf64_get: (a: number, b: number, c: number) => number;
  readonly matrixf64_row: (a: number, b: number) => number;
  readonly matrixf64_col: (a: number, b: number) => number;
  readonly matrixf64_multiply_vector: (a: number, b: number) => number;
  readonly matrixf64_diagonal: (a: number) => number;
  readonly matrixf64_solve: (a: number, b: number) => number;
  readonly vectorf64_transpose: (a: number) => number;
  readonly vectorf64_to_column_matrix: (a: number) => number;
  readonly vectorf64_to_row_matrix: (a: number) => number;
  readonly __wbg_matrixf32_free: (a: number, b: number) => void;
  readonly matrixf32_add: (a: number, b: number) => number;
  readonly matrixf32_sub: (a: number, b: number) => number;
  readonly matrixf32_mul: (a: number, b: number) => number;
  readonly matrixf32_new: (a: number, b: number, c: number, d: number) => [number, number, number];
  readonly matrixf32_with_default: (a: number, b: number) => number;
  readonly matrixf32_zeros: (a: number, b: number) => number;
  readonly matrixf32_identity: (a: number) => number;
  readonly matrixf32_rows: (a: number) => number;
  readonly matrixf32_cols: (a: number) => number;
  readonly matrixf32_is_square: (a: number) => number;
  readonly matrixf32_transpose: (a: number) => number;
  readonly matrixf32_trace: (a: number) => [number, number, number];
  readonly matrixf32_determinant: (a: number) => [number, number, number];
  readonly matrixf32_rank: (a: number) => [number, number, number];
  readonly matrixf32_inverse: (a: number) => number;
  readonly __wbg_vectorf32_free: (a: number, b: number) => void;
  readonly vectorf32_add: (a: number, b: number) => number;
  readonly vectorf32_sub: (a: number, b: number) => number;
  readonly vectorf32_mul: (a: number, b: number) => number;
  readonly vectorf32_new: (a: number, b: number) => number;
  readonly vectorf32_zeros: (a: number) => number;
  readonly vectorf32_ones: (a: number) => number;
  readonly vectorf32_dim: (a: number) => number;
  readonly vectorf32_is_empty: (a: number) => number;
  readonly vectorf32_dot: (a: number, b: number) => number;
  readonly vectorf32_argmax: (a: number) => number;
  readonly vectorf32_argmin: (a: number) => number;
  readonly vectorf32_max: (a: number) => number;
  readonly vectorf32_min: (a: number) => number;
  readonly __wbg_matrixi32_free: (a: number, b: number) => void;
  readonly matrixi32_add: (a: number, b: number) => number;
  readonly matrixi32_sub: (a: number, b: number) => number;
  readonly matrixi32_mul: (a: number, b: number) => number;
  readonly matrixi32_new: (a: number, b: number, c: number, d: number) => [number, number, number];
  readonly matrixi32_identity: (a: number) => number;
  readonly matrixi32_transpose: (a: number) => number;
  readonly matrixi32_trace: (a: number) => [number, number, number];
  readonly __wbg_vectori32_free: (a: number, b: number) => void;
  readonly vectori32_add: (a: number, b: number) => number;
  readonly vectori32_sub: (a: number, b: number) => number;
  readonly vectori32_mul: (a: number, b: number) => number;
  readonly vectori32_ones: (a: number) => number;
  readonly vectori32_dot: (a: number, b: number) => number;
  readonly vectori32_argmax: (a: number) => number;
  readonly vectori32_argmin: (a: number) => number;
  readonly vectori32_max: (a: number) => number;
  readonly vectori32_min: (a: number) => number;
  readonly matrixf64_is_square: (a: number) => number;
  readonly matrixi32_is_square: (a: number) => number;
  readonly vectori32_is_empty: (a: number) => number;
  readonly vectori32_new: (a: number, b: number) => number;
  readonly matrixf64_rows: (a: number) => number;
  readonly matrixf64_cols: (a: number) => number;
  readonly matrixi32_rows: (a: number) => number;
  readonly matrixi32_cols: (a: number) => number;
  readonly matrixi32_zeros: (a: number, b: number) => number;
  readonly matrixi32_with_default: (a: number, b: number) => number;
  readonly vectorf64_len: (a: number) => number;
  readonly vectorf32_len: (a: number) => number;
  readonly vectori32_dim: (a: number) => number;
  readonly vectori32_len: (a: number) => number;
  readonly vectori32_zeros: (a: number) => number;
  readonly __wbg_polynomialf64_free: (a: number, b: number) => void;
  readonly polynomialf64_add: (a: number, b: number) => number;
  readonly polynomialf64_sub: (a: number, b: number) => number;
  readonly polynomialf64_mul: (a: number, b: number) => number;
  readonly polynomialf64_div: (a: number, b: number) => number;
  readonly __wbg_polynomialgf2_free: (a: number, b: number) => void;
  readonly polynomialgf2_add: (a: number, b: number) => number;
  readonly polynomialgf2_sub: (a: number, b: number) => number;
  readonly polynomialgf2_mul: (a: number, b: number) => number;
  readonly polynomialgf2_div: (a: number, b: number) => number;
  readonly __wbg_polynomialgf256_free: (a: number, b: number) => void;
  readonly polynomialgf256_add: (a: number, b: number) => number;
  readonly polynomialgf256_sub: (a: number, b: number) => number;
  readonly polynomialgf256_mul: (a: number, b: number) => number;
  readonly polynomialgf256_div: (a: number, b: number) => number;
  readonly __wbg_polynomialgfextgf2_free: (a: number, b: number) => void;
  readonly polynomialgfextgf2_add: (a: number, b: number) => number;
  readonly polynomialgfextgf2_sub: (a: number, b: number) => number;
  readonly polynomialgfextgf2_mul: (a: number, b: number) => number;
  readonly polynomialgfextgf2_div: (a: number, b: number) => number;
  readonly polynomialf64_divRem: (a: number, b: number) => [number, number];
  readonly polynomialgf2_divRem: (a: number, b: number) => [number, number];
  readonly polynomialgf256_divRem: (a: number, b: number) => [number, number];
  readonly polynomialgfextgf2_divRem: (a: number, b: number) => [number, number];
  readonly polynomialf64_new: (a: number, b: number) => number;
  readonly polynomialf64_deg: (a: number) => number;
  readonly polynomialf64_get: (a: number, b: number) => number;
  readonly polynomialf64_eval: (a: number, b: number) => number;
  readonly polynomialgf2_new: (a: number, b: number) => number;
  readonly polynomialgf2_deg: (a: number) => number;
  readonly polynomialgf2_get: (a: number, b: number) => number;
  readonly polynomialgf2_eval: (a: number, b: number) => number;
  readonly polynomialgf256_new: (a: number, b: number) => number;
  readonly polynomialgf256_deg: (a: number) => number;
  readonly polynomialgf256_get: (a: number, b: number) => number;
  readonly polynomialgf256_eval: (a: number, b: number) => number;
  readonly polynomialgfextgf2_new: (a: number, b: number, c: number, d: number) => number;
  readonly polynomialgfextgf2_get: (a: number, b: number) => [number, number];
  readonly polynomialgfextgf2_eval: (a: number, b: number, c: number) => [number, number];
  readonly __wbg_wasmsignal_free: (a: number, b: number) => void;
  readonly wasmsignal_new: (a: number, b: number, c: number) => number;
  readonly wasmsignal_data: (a: number) => [number, number];
  readonly wasmsignal_sample_rate: (a: number) => number;
  readonly wasmsignal_len: (a: number) => number;
  readonly wasmsignal_dft: (a: number) => number;
  readonly wasmsignal_convolve: (a: number, b: number) => number;
  readonly wasmsignal_apply_fir: (a: number, b: number, c: number) => number;
  readonly wasmsignal_downsample: (a: number, b: number, c: number) => number;
  readonly wasmsignal_upsample: (a: number, b: number, c: number) => number;
  readonly wasmsignal_resample: (a: number, b: number, c: number, d: number) => number;
  readonly wasmsignal_decimate: (a: number, b: number) => number;
  readonly wasmsignal_expand: (a: number, b: number) => number;
  readonly wasmsignal_save_svg_simple: (a: number, b: number, c: number) => [number, number];
  readonly wasmsignal_save_svg_with_axes: (a: number, b: number, c: number, d: number, e: number) => [number, number];
  readonly __wbg_wasmspectrum_free: (a: number, b: number) => void;
  readonly wasmspectrum_data_interleaved: (a: number) => [number, number];
  readonly wasmspectrum_len: (a: number) => number;
  readonly wasmspectrum_ift: (a: number) => number;
  readonly wasmspectrum_magnitude_db_svg: (a: number, b: number, c: number, d: number, e: number) => [number, number];
  readonly window_hann: (a: number) => [number, number];
  readonly window_hamming: (a: number) => [number, number];
  readonly window_blackman: (a: number) => [number, number];
  readonly window_rectangular: (a: number) => [number, number];
  readonly window_kaiser: (a: number, b: number) => [number, number];
  readonly sp_design_fir_lowpass: (a: number, b: number) => [number, number];
  readonly sp_design_fir_highpass: (a: number, b: number) => [number, number];
  readonly sp_design_fir_bandpass: (a: number, b: number, c: number) => [number, number];
  readonly sp_design_fir_bandstop: (a: number, b: number, c: number) => [number, number];
  readonly sp_design_iir_butter_lowpass: (a: number, b: number, c: number) => number;
  readonly sp_design_iir_butter_highpass: (a: number, b: number, c: number) => number;
  readonly sp_design_iir_butter_bandpass: (a: number, b: number, c: number, d: number) => number;
  readonly sp_design_iir_butter_bandstop: (a: number, b: number, c: number, d: number) => number;
  readonly sp_design_iir_cheby1_lowpass: (a: number, b: number, c: number, d: number) => number;
  readonly sp_design_iir_cheby2_lowpass: (a: number, b: number, c: number, d: number) => number;
  readonly __wbg_wasmlms_free: (a: number, b: number) => void;
  readonly wasmlms_new: (a: number, b: number) => number;
  readonly wasmlms_process_sample: (a: number, b: number, c: number) => [number, number];
  readonly wasmlms_process_series: (a: number, b: number, c: number, d: number, e: number) => [number, number];
  readonly __wbg_wasmnlms_free: (a: number, b: number) => void;
  readonly wasmnlms_new: (a: number, b: number, c: number) => number;
  readonly wasmnlms_process_sample: (a: number, b: number, c: number) => [number, number];
  readonly wasmnlms_process_series: (a: number, b: number, c: number, d: number, e: number) => [number, number];
  readonly img_convolve2d_f32_simple: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => [number, number];
  readonly img_convolve2d_f32: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => [number, number];
  readonly img_convolve2d_u8: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => [number, number];
  readonly img_dft2d: (a: number, b: number, c: number, d: number) => [number, number];
  readonly img_idft2d: (a: number, b: number, c: number, d: number) => [number, number];
  readonly img_fftshift: (a: number, b: number, c: number, d: number) => [number, number];
  readonly img_magnitude: (a: number, b: number, c: number, d: number) => [number, number];
  readonly img_gaussian_blur_f32: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => [number, number];
  readonly img_gaussian_blur_u8: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => [number, number];
  readonly img_box_filter_f32: (a: number, b: number, c: number, d: number, e: number, f: number) => [number, number];
  readonly img_box_filter_u8: (a: number, b: number, c: number, d: number, e: number, f: number) => [number, number];
  readonly img_unsharp_mask_f32: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number) => [number, number];
  readonly img_unsharp_mask_u8: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number) => [number, number];
  readonly img_sobel_magnitude_f32: (a: number, b: number, c: number, d: number, e: number) => [number, number];
  readonly img_sobel_magnitude_u8: (a: number, b: number, c: number, d: number, e: number) => [number, number];
  readonly img_laplacian_f32: (a: number, b: number, c: number, d: number, e: number) => [number, number];
  readonly img_laplacian_u8: (a: number, b: number, c: number, d: number, e: number) => [number, number];
  readonly img_median_filter_f32: (a: number, b: number, c: number, d: number, e: number, f: number) => [number, number];
  readonly img_median_filter_u8: (a: number, b: number, c: number, d: number, e: number, f: number) => [number, number];
  readonly img_bilateral_filter_f32: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number) => [number, number];
  readonly img_bilateral_filter_u8: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number) => [number, number];
  readonly rgb_u8_to_gray_f64: (a: number, b: number, c: number, d: number) => [number, number];
  readonly rgba_u8_to_gray_f64: (a: number, b: number, c: number, d: number) => [number, number];
  readonly gray_f64_to_rgba_u8: (a: number, b: number, c: number, d: number) => [number, number];
  readonly u8_to_gray_f64: (a: number, b: number) => [number, number];
  readonly gray_f64_to_u8_clamped: (a: number, b: number) => [number, number];
  readonly img_convolve2d_f32_io: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => [number, number];
  readonly img_gaussian_blur_f32_io: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => [number, number];
  readonly wasmspectrum_new: (a: number, b: number, c: number) => number;
  readonly wasmspectrum_sample_rate: (a: number) => number;
  readonly polynomialgfextgf2_deg: (a: number) => number;
  readonly __wbg_wasmgf2_free: (a: number, b: number) => void;
  readonly wasmgf2_inv: (a: number) => [number, number, number];
  readonly wasmgf2_add: (a: number, b: number) => number;
  readonly wasmgf2_sub: (a: number, b: number) => number;
  readonly wasmgf2_mul: (a: number, b: number) => number;
  readonly wasmgf2_div: (a: number, b: number) => [number, number, number];
  readonly wasmgf2_neg: (a: number) => number;
  readonly __wbg_wasmgf3_free: (a: number, b: number) => void;
  readonly wasmgf3_inv: (a: number) => [number, number, number];
  readonly wasmgf3_add: (a: number, b: number) => number;
  readonly wasmgf3_sub: (a: number, b: number) => number;
  readonly wasmgf3_mul: (a: number, b: number) => number;
  readonly wasmgf3_div: (a: number, b: number) => [number, number, number];
  readonly wasmgf3_neg: (a: number) => number;
  readonly __wbg_wasmgf256_free: (a: number, b: number) => void;
  readonly wasmgf256_is_zero: (a: number) => number;
  readonly wasmgf256_is_one: (a: number) => number;
  readonly wasmgf256_toU8: (a: number) => number;
  readonly wasmgf256_inv: (a: number) => [number, number, number];
  readonly wasmgf256_add: (a: number, b: number) => number;
  readonly wasmgf256_sub: (a: number, b: number) => number;
  readonly wasmgf256_mul: (a: number, b: number) => number;
  readonly wasmgf256_new: (a: number) => number;
  readonly wasmgf256_coeffs: (a: number) => [number, number];
  readonly wasmgf256_fromCoeffs: (a: number, b: number) => number;
  readonly wasmgf256_modulus: () => [number, number];
  readonly __wbg_wasmgfextgf2_free: (a: number, b: number) => void;
  readonly wasmgfextgf2_inv: (a: number) => [number, number, number];
  readonly wasmgfextgf2_add: (a: number, b: number) => number;
  readonly wasmgfextgf2_sub: (a: number, b: number) => number;
  readonly wasmgfextgf2_mul: (a: number, b: number) => number;
  readonly wasmgfextgf2_new: (a: number, b: number, c: number, d: number) => number;
  readonly wasmgfextgf2_fromBase: (a: number, b: number, c: number) => number;
  readonly wasmgfextgf2_coeffs: (a: number) => [number, number];
  readonly wasmgfextgf2_px: (a: number) => [number, number];
  readonly wasmgf256_div: (a: number, b: number) => [number, number, number];
  readonly wasmgf256_neg: (a: number) => number;
  readonly wasmgfextgf2_div: (a: number, b: number) => [number, number, number];
  readonly wasmgfextgf2_neg: (a: number) => number;
  readonly __wbg_gf2_free: (a: number, b: number) => void;
  readonly gf2_new: (a: bigint) => number;
  readonly gf2_modulus: () => number;
  readonly gf2_inv: (a: number) => [number, number, number];
  readonly gf2_zero: () => number;
  readonly gf2_one: () => number;
  readonly gf2_add: (a: number, b: number) => number;
  readonly gf2_sub: (a: number, b: number) => number;
  readonly gf2_mul: (a: number, b: number) => number;
  readonly gf2_div: (a: number, b: number) => [number, number, number];
  readonly gf2_neg: (a: number) => number;
  readonly gf2_value: (a: number) => bigint;
  readonly gf2_is_zero: (a: number) => number;
  readonly gf2_is_one: (a: number) => number;
  readonly __wbg_gf3_free: (a: number, b: number) => void;
  readonly gf3_new: (a: bigint) => number;
  readonly gf3_modulus: () => number;
  readonly gf3_inv: (a: number) => [number, number, number];
  readonly gf3_add: (a: number, b: number) => number;
  readonly gf3_sub: (a: number, b: number) => number;
  readonly gf3_mul: (a: number, b: number) => number;
  readonly gf3_div: (a: number, b: number) => [number, number, number];
  readonly gf3_neg: (a: number) => number;
  readonly __wbg_gfextgf2_free: (a: number, b: number) => void;
  readonly gfextgf2_new: (a: number, b: number, c: number, d: number) => number;
  readonly gfextgf2_fromBase: (a: number, b: number, c: number) => number;
  readonly gfextgf2_inv: (a: number) => [number, number, number];
  readonly gfextgf2_zero: () => number;
  readonly gfextgf2_one: () => number;
  readonly gfextgf2_add: (a: number, b: number) => number;
  readonly gfextgf2_sub: (a: number, b: number) => number;
  readonly gfextgf2_mul: (a: number, b: number) => number;
  readonly gfextgf2_div: (a: number, b: number) => [number, number, number];
  readonly gfextgf2_neg: (a: number) => number;
  readonly gfextgf2_coeffs: (a: number) => [number, number];
  readonly gfextgf2_px: (a: number) => [number, number];
  readonly __probe: () => number;
  readonly __wbg_matrix_free: (a: number, b: number) => void;
  readonly matrix_new: (a: number, b: number, c: number, d: number) => [number, number, number];
  readonly matrix_with_default: (a: number, b: number) => number;
  readonly matrix_zeros: (a: number, b: number) => number;
  readonly matrix_identity: (a: number) => number;
  readonly matrix_rows: (a: number) => number;
  readonly matrix_cols: (a: number) => number;
  readonly matrix_is_square: (a: number) => number;
  readonly matrix_transpose: (a: number) => number;
  readonly matrix_trace: (a: number) => [number, number, number];
  readonly matrix_determinant: (a: number) => [number, number, number];
  readonly matrix_rank: (a: number) => [number, number, number];
  readonly matrix_inverse: (a: number) => number;
  readonly matrix_frobenius_norm: (a: number) => number;
  readonly matrix_expm: (a: number) => number;
  readonly matrix_qr_decomposition: (a: number) => [number, number, number];
  readonly matrix_svd: (a: number) => [number, number, number];
  readonly matrix_eigen_decomposition: (a: number) => [number, number, number];
  readonly matrix_cholesky: (a: number) => [number, number, number];
  readonly matrix_pinv: (a: number) => [number, number, number];
  readonly __wbg_vector_free: (a: number, b: number) => void;
  readonly vector_new: (a: number, b: number) => number;
  readonly vector_zeros: (a: number) => number;
  readonly vector_ones: (a: number) => number;
  readonly vector_dim: (a: number) => number;
  readonly vector_is_empty: (a: number) => number;
  readonly vector_dot: (a: number, b: number) => number;
  readonly vector_argmax: (a: number) => number;
  readonly vector_argmin: (a: number) => number;
  readonly vector_max: (a: number) => [number, number];
  readonly vector_min: (a: number) => [number, number];
  readonly vector_norm: (a: number) => number;
  readonly vector_normalize: (a: number) => number;
  readonly vector_cosine_similarity: (a: number, b: number) => number;
  readonly vector_mean: (a: number) => [number, number];
  readonly vector_std: (a: number) => number;
  readonly vector_linspace: (a: number, b: number, c: number) => [number, number, number];
  readonly vector_sum: (a: number) => number;
  readonly vector_transpose: (a: number) => number;
  readonly vector_to_column_matrix: (a: number) => number;
  readonly vector_to_row_matrix: (a: number) => number;
  readonly solveLinearSystem: (a: number, b: number, c: number, d: number, e: number, f: number) => [number, number, number, number];
  readonly ridgeRegression: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => [number, number, number, number];
  readonly lassoRegression: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => [number, number, number, number];
  readonly logisticFit: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number) => [number, number, number, number];
  readonly logisticPredictProba: (a: number, b: number, c: number, d: number, e: number) => [number, number, number];
  readonly gmmFit: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => [number, number, number, number];
  readonly gmmPredictProba: (a: number, b: number, c: number, d: number, e: number) => [number, number, number, number];
  readonly bayesianLinearPosterior: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number) => [number, number, number, number];
  readonly kalmanPredict: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => [number, number, number, number];
  readonly kalmanUpdate: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number) => [number, number, number, number];
  readonly wasmgf3_is_zero: (a: number) => number;
  readonly wasmgf3_is_one: (a: number) => number;
  readonly wasmgf2_is_zero: (a: number) => number;
  readonly wasmgf2_is_one: (a: number) => number;
  readonly gf3_is_zero: (a: number) => number;
  readonly gf3_is_one: (a: number) => number;
  readonly init: () => void;
  readonly wasmgfextgf2_zero: () => number;
  readonly wasmgfextgf2_one: () => number;
  readonly wasmgf256_zero: () => number;
  readonly wasmgf256_one: () => number;
  readonly wasmgf256_value: (a: number) => number;
  readonly wasmgf2_new: (a: bigint) => number;
  readonly wasmgf3_zero: () => number;
  readonly wasmgf3_one: () => number;
  readonly wasmgf2_zero: () => number;
  readonly wasmgf2_one: () => number;
  readonly gf3_zero: () => number;
  readonly gf3_one: () => number;
  readonly wasmgfextgf2_is_zero: (a: number) => number;
  readonly wasmgfextgf2_is_one: (a: number) => number;
  readonly wasmgf2_modulus: () => number;
  readonly wasmgf3_modulus: () => number;
  readonly wasmgf3_new: (a: bigint) => number;
  readonly vector_len: (a: number) => number;
  readonly wasmgf3_value: (a: number) => bigint;
  readonly wasmgf2_value: (a: number) => bigint;
  readonly gf3_value: (a: number) => bigint;
  readonly convolveNaiveF64: (a: number, b: number, c: number, d: number) => [number, number];
  readonly convolveFftF64: (a: number, b: number, c: number, d: number) => [number, number, number, number];
  readonly convolveAutoF64: (a: number, b: number, c: number, d: number, e: number) => [number, number, number, number];
  readonly defaultConvolutionThreshold: () => number;
  readonly dftComplexF64: (a: number, b: number) => [number, number];
  readonly iftComplexF64: (a: number, b: number) => [number, number];
  readonly binom: (a: number, b: number) => number;
  readonly stirling2: (a: number, b: number) => number;
  readonly fallingFactorialPoly: (a: number) => [number, number];
  readonly risingFactorialPoly: (a: number) => [number, number];
  readonly shiftPolyXPlusH: (a: number, b: number, c: number) => [number, number];
  readonly discreteDiff: (a: number, b: number) => [number, number];
  readonly discreteSum: (a: number, b: number) => [number, number];
  readonly __wbg_closedform_free: (a: number, b: number) => void;
  readonly closedform_termsCount: (a: number) => number;
  readonly closedform_termPoly: (a: number, b: number) => [number, number, number, number];
  readonly closedform_termBase: (a: number, b: number) => [number, number, number, number];
  readonly closedform_term: (a: number, b: number) => [number, number];
  readonly solveRecurrence: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number) => [number, number, number];
  readonly __wbg_discretetf_free: (a: number, b: number) => void;
  readonly wasmdiscretetf_new: (a: number, b: number, c: number, d: number, e: number) => number;
  readonly wasmdiscretetf_sample_rate: (a: number) => number;
  readonly wasmdiscretetf_set_sample_rate: (a: number, b: number) => void;
  readonly wasmdiscretetf_b_coeffs: (a: number) => [number, number];
  readonly wasmdiscretetf_a_coeffs: (a: number) => [number, number];
  readonly wasmdiscretetf_is_stable: (a: number) => number;
  readonly wasmdiscretetf_impulse_response: (a: number, b: number) => [number, number];
  readonly wasmdiscretetf_step_response: (a: number, b: number) => [number, number];
  readonly wasmdiscretetf_frequency_response_mag_phase: (a: number, b: number) => [number, number];
  readonly wasmdiscretetf_bode_svg: (a: number, b: number, c: number, d: number, e: number, f: number) => [number, number];
  readonly wasmdiscretetf_nyquist_svg: (a: number, b: number, c: number, d: number, e: number, f: number) => [number, number];
  readonly wasmdiscretetf_series: (a: number, b: number) => number;
  readonly wasmdiscretetf_parallel: (a: number, b: number) => number;
  readonly wasmdiscretetf_feedback_unity: (a: number) => number;
  readonly wasmdiscretetf_block_feedback_svg: (a: number, b: number, c: number, d: number, e: number, f: number) => [number, number];
  readonly __wbg_continuoustf_free: (a: number, b: number) => void;
  readonly wasmcontinuoustf_new: (a: number, b: number, c: number, d: number) => number;
  readonly wasmcontinuoustf_b_coeffs: (a: number) => [number, number];
  readonly wasmcontinuoustf_a_coeffs: (a: number) => [number, number];
  readonly wasmcontinuoustf_is_stable: (a: number) => number;
  readonly wasmcontinuoustf_impulse_response: (a: number, b: number, c: number) => [number, number];
  readonly wasmcontinuoustf_step_response: (a: number, b: number, c: number) => [number, number];
  readonly wasmcontinuoustf_frequency_response_mag_phase: (a: number, b: number, c: number) => [number, number];
  readonly wasmcontinuoustf_to_discrete_bilinear: (a: number, b: number) => number;
  readonly wasmcontinuoustf_to_discrete_bilinear_prewarp: (a: number, b: number, c: number) => number;
  readonly wasmcontinuoustf_bode_svg: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => [number, number];
  readonly wasmcontinuoustf_nyquist_svg: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number) => [number, number];
  readonly wasmcontinuoustf_block_feedback_svg: (a: number, b: number, c: number, d: number, e: number, f: number) => [number, number];
  readonly __wbg_continuouszpk_free: (a: number, b: number) => void;
  readonly wasmcontinuouszpk_new: (a: number, b: number, c: number, d: number, e: number) => number;
  readonly wasmcontinuouszpk_from_tf: (a: number) => number;
  readonly wasmcontinuouszpk_to_tf: (a: number) => number;
  readonly wasmcontinuouszpk_zeros_interleaved: (a: number) => [number, number];
  readonly wasmcontinuouszpk_poles_interleaved: (a: number) => [number, number];
  readonly wasmcontinuouszpk_gain: (a: number) => number;
  readonly __wbg_discretezpk_free: (a: number, b: number) => void;
  readonly wasmdiscretezpk_new: (a: number, b: number, c: number, d: number, e: number, f: number) => number;
  readonly wasmdiscretezpk_from_tf: (a: number) => number;
  readonly wasmdiscretezpk_to_tf: (a: number) => number;
  readonly wasmdiscretezpk_zeros_interleaved: (a: number) => [number, number];
  readonly wasmdiscretezpk_poles_interleaved: (a: number) => [number, number];
  readonly wasmdiscretezpk_sample_rate: (a: number) => number;
  readonly __wbg_continuousss_free: (a: number, b: number) => void;
  readonly wasmcontinuousss_new: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number, m: number, n: number, o: number, p: number) => number;
  readonly wasmcontinuousss_from_tf_siso: (a: number, b: number, c: number, d: number) => number;
  readonly wasmcontinuousss_to_tf_siso: (a: number) => [number, number];
  readonly wasmcontinuousss_c2d_zoh: (a: number, b: number) => number;
  readonly wasmcontinuousss_a_flat: (a: number) => [number, number];
  readonly wasmcontinuousss_b_flat: (a: number) => [number, number];
  readonly wasmcontinuousss_c_flat: (a: number) => [number, number];
  readonly wasmcontinuousss_d_flat: (a: number) => [number, number];
  readonly wasmcontinuousss_a_shape: (a: number) => [number, number];
  readonly wasmcontinuousss_b_shape: (a: number) => [number, number];
  readonly wasmcontinuousss_c_shape: (a: number) => [number, number];
  readonly wasmcontinuousss_d_shape: (a: number) => [number, number];
  readonly __wbg_discretess_free: (a: number, b: number) => void;
  readonly wasmdiscretess_to_tf_siso: (a: number) => [number, number];
  readonly wasmdiscretess_a_flat: (a: number) => [number, number];
  readonly wasmdiscretess_b_flat: (a: number) => [number, number];
  readonly wasmdiscretess_c_flat: (a: number) => [number, number];
  readonly wasmdiscretess_d_flat: (a: number) => [number, number];
  readonly wasmdiscretess_a_shape: (a: number) => [number, number];
  readonly wasmdiscretess_b_shape: (a: number) => [number, number];
  readonly wasmdiscretess_c_shape: (a: number) => [number, number];
  readonly wasmdiscretess_d_shape: (a: number) => [number, number];
  readonly wasmdiscretezpk_gain: (a: number) => number;
  readonly wasmdiscretess_new: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number, m: number, n: number, o: number, p: number) => number;
  readonly __wbg_hamming74_free: (a: number, b: number) => void;
  readonly wasmhamming74_new: () => number;
  readonly wasmhamming74_encode: (a: number, b: number, c: number) => [number, number, number, number];
  readonly __wbg_linearcode_free: (a: number, b: number) => void;
  readonly linearcode_new: (a: number, b: number, c: number, d: number) => [number, number, number];
  readonly linearcode_encode: (a: number, b: number, c: number) => [number, number, number, number];
  readonly __wbg_cycliccode_free: (a: number, b: number) => void;
  readonly cycliccode_new: (a: number, b: number, c: number) => number;
  readonly cycliccode_encode: (a: number, b: number, c: number) => [number, number, number, number];
  readonly __wbg_reedsolomon_free: (a: number, b: number) => void;
  readonly reedsolomon_new: (a: number, b: number, c: number) => [number, number, number];
  readonly reedsolomon_encode: (a: number, b: number, c: number) => [number, number, number, number];
  readonly reedsolomon_decode: (a: number, b: number, c: number) => [number, number, number, number];
  readonly reedsolomon_n: (a: number) => number;
  readonly reedsolomon_t: (a: number) => number;
  readonly __wbg_bch_free: (a: number, b: number) => void;
  readonly bch_new: (a: number, b: number, c: number) => number;
  readonly bch_encode: (a: number, b: number, c: number) => [number, number, number, number];
  readonly bch_k: (a: number) => number;
  readonly bch_n: (a: number) => number;
  readonly bch_t: (a: number) => number;
  readonly hammingDistanceGF2: (a: number, b: number, c: number, d: number) => number;
  readonly weightDistributionGF2: (a: number, b: number, c: number) => [number, number, number, number];
  readonly nt_factor_u64: (a: bigint) => [number, number];
  readonly nt_factor_bigint_str: (a: number, b: number) => [number, number];
  readonly __wbg_wasmlinearmodel_free: (a: number, b: number) => void;
  readonly wasmlinearmodel_solveLinearSystem: (a: number, b: number, c: number, d: number, e: number, f: number) => [number, number, number, number];
  readonly wasmlinearmodel_ridgeRegression: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => [number, number, number, number];
  readonly wasmlinearmodel_lassoRegression: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => [number, number, number, number];
  readonly cycliccode_k: (a: number) => number;
  readonly __wbg_normal_free: (a: number, b: number) => void;
  readonly __wbg_uniform_free: (a: number, b: number) => void;
  readonly uniform_new: (a: number, b: number) => [number, number, number];
  readonly uniform_mean: (a: number) => number;
  readonly uniform_variance: (a: number) => number;
  readonly uniform_std_dev: (a: number) => number;
  readonly uniform_pdf: (a: number, b: number) => number;
  readonly uniform_cdf: (a: number, b: number) => number;
  readonly uniform_quantile: (a: number, b: number) => number;
  readonly uniform_pdf_svg: (a: number, b: number, c: number, d: number) => [number, number];
  readonly __wbg_studentt_free: (a: number, b: number) => void;
  readonly studentt_new: (a: number) => [number, number, number];
  readonly studentt_mean: (a: number) => number;
  readonly studentt_variance: (a: number) => number;
  readonly studentt_std_dev: (a: number) => number;
  readonly studentt_pdf: (a: number, b: number) => number;
  readonly studentt_cdf: (a: number, b: number) => number;
  readonly studentt_quantile: (a: number, b: number) => number;
  readonly studentt_pdf_svg: (a: number, b: number, c: number, d: number) => [number, number];
  readonly __wbg_chisquare_free: (a: number, b: number) => void;
  readonly chisquare_new: (a: number) => [number, number, number];
  readonly chisquare_mean: (a: number) => number;
  readonly chisquare_variance: (a: number) => number;
  readonly chisquare_std_dev: (a: number) => number;
  readonly chisquare_pdf: (a: number, b: number) => number;
  readonly chisquare_cdf: (a: number, b: number) => number;
  readonly chisquare_quantile: (a: number, b: number) => number;
  readonly chisquare_pdf_svg: (a: number, b: number, c: number, d: number) => [number, number];
  readonly __wbg_f_free: (a: number, b: number) => void;
  readonly f_new: (a: number, b: number) => [number, number, number];
  readonly f_mean: (a: number) => number;
  readonly f_variance: (a: number) => number;
  readonly f_std_dev: (a: number) => number;
  readonly f_pdf: (a: number, b: number) => number;
  readonly f_cdf: (a: number, b: number) => number;
  readonly f_quantile: (a: number, b: number) => number;
  readonly f_pdf_svg: (a: number, b: number, c: number, d: number) => [number, number];
  readonly __wbg_binomial_free: (a: number, b: number) => void;
  readonly binomial_new: (a: number, b: number) => [number, number, number];
  readonly binomial_mean: (a: number) => number;
  readonly binomial_variance: (a: number) => number;
  readonly binomial_std_dev: (a: number) => number;
  readonly binomial_pmf: (a: number, b: number) => number;
  readonly binomial_cdf: (a: number, b: number) => number;
  readonly binomial_quantile: (a: number, b: number) => number;
  readonly binomial_pmf_svg: (a: number, b: number, c: number) => [number, number];
  readonly __wbg_categorical_free: (a: number, b: number) => void;
  readonly categorical_new: (a: number, b: number) => [number, number, number];
  readonly categorical_pmf: (a: number, b: number) => number;
  readonly categorical_log_pmf: (a: number, b: number) => number;
  readonly categorical_cdf: (a: number, b: number) => number;
  readonly categorical_quantile: (a: number, b: number) => number;
  readonly categorical_pmf_svg: (a: number, b: number, c: number) => [number, number];
  readonly normal_new: (a: number, b: number) => [number, number, number];
  readonly normal_mean: (a: number) => number;
  readonly normal_variance: (a: number) => number;
  readonly normal_std_dev: (a: number) => number;
  readonly normal_pdf: (a: number, b: number) => number;
  readonly normal_cdf: (a: number, b: number) => number;
  readonly normal_quantile: (a: number, b: number) => number;
  readonly normal_pdf_svg: (a: number, b: number, c: number, d: number) => [number, number];
  readonly __wbg_gamma_free: (a: number, b: number) => void;
  readonly gamma_new: (a: number, b: number) => [number, number, number];
  readonly gamma_mean: (a: number) => number;
  readonly gamma_variance: (a: number) => number;
  readonly gamma_std_dev: (a: number) => number;
  readonly gamma_pdf: (a: number, b: number) => number;
  readonly gamma_cdf: (a: number, b: number) => number;
  readonly gamma_quantile: (a: number, b: number) => number;
  readonly gamma_pdf_svg: (a: number, b: number, c: number, d: number) => [number, number];
  readonly __wbg_exponential_free: (a: number, b: number) => void;
  readonly exponential_new: (a: number) => [number, number, number];
  readonly exponential_mean: (a: number) => number;
  readonly exponential_variance: (a: number) => number;
  readonly exponential_std_dev: (a: number) => number;
  readonly exponential_pdf: (a: number, b: number) => number;
  readonly exponential_cdf: (a: number, b: number) => number;
  readonly exponential_quantile: (a: number, b: number) => number;
  readonly exponential_pdf_svg: (a: number, b: number, c: number, d: number) => [number, number];
  readonly __wbg_bernoulli_free: (a: number, b: number) => void;
  readonly bernoulli_new: (a: number) => [number, number, number];
  readonly bernoulli_mean: (a: number) => number;
  readonly bernoulli_variance: (a: number) => number;
  readonly bernoulli_std_dev: (a: number) => number;
  readonly bernoulli_pmf: (a: number, b: number) => number;
  readonly bernoulli_cdf: (a: number, b: number) => number;
  readonly bernoulli_quantile: (a: number, b: number) => number;
  readonly bernoulli_pmf_svg: (a: number, b: number, c: number) => [number, number];
  readonly __wbg_poisson_free: (a: number, b: number) => void;
  readonly poisson_new: (a: number) => [number, number, number];
  readonly poisson_std_dev: (a: number) => number;
  readonly poisson_pmf: (a: number, b: number) => number;
  readonly poisson_log_pmf: (a: number, b: number) => number;
  readonly poisson_cdf: (a: number, b: number) => number;
  readonly poisson_quantile: (a: number, b: number) => number;
  readonly poisson_pmf_svg: (a: number, b: number, c: number) => [number, number];
  readonly poisson_mean: (a: number) => number;
  readonly poisson_variance: (a: number) => number;
  readonly erf: (a: number) => number;
  readonly erfc: (a: number) => number;
  readonly erfInv: (a: number) => number;
  readonly gamma: (a: number) => number;
  readonly logGamma: (a: number) => number;
  readonly regularizedGamma: (a: number, b: number) => number;
  readonly beta: (a: number, b: number) => number;
  readonly logBeta: (a: number, b: number) => number;
  readonly regularizedBeta: (a: number, b: number, c: number) => number;
  readonly __wbindgen_exn_store: (a: number) => void;
  readonly __externref_table_alloc: () => number;
  readonly __wbindgen_export_2: WebAssembly.Table;
  readonly __wbindgen_free: (a: number, b: number, c: number) => void;
  readonly __wbindgen_malloc: (a: number, b: number) => number;
  readonly __wbindgen_realloc: (a: number, b: number, c: number, d: number) => number;
  readonly __externref_table_dealloc: (a: number) => void;
  readonly __externref_drop_slice: (a: number, b: number) => void;
  readonly __wbindgen_start: () => void;
}

export type SyncInitInput = BufferSource | WebAssembly.Module;
/**
* Instantiates the given `module`, which can either be bytes or
* a precompiled `WebAssembly.Module`.
*
* @param {{ module: SyncInitInput }} module - Passing `SyncInitInput` directly is deprecated.
*
* @returns {InitOutput}
*/
export function initSync(module: { module: SyncInitInput } | SyncInitInput): InitOutput;

/**
* If `module_or_path` is {RequestInfo} or {URL}, makes a request and
* for everything else, calls `WebAssembly.instantiate` directly.
*
* @param {{ module_or_path: InitInput | Promise<InitInput> }} module_or_path - Passing `InitInput` directly is deprecated.
*
* @returns {Promise<InitOutput>}
*/
export default function __wbg_init (module_or_path?: { module_or_path: InitInput | Promise<InitInput> } | InitInput | Promise<InitInput>): Promise<InitOutput>;
