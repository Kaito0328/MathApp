# BCH code（coding/src/bch.rs）

## 背景知識
BCHは巡回符号であり, 拡大体GF(q^m)の原始元 α に対して連続根 {α^b..α^{b+2t−1}} を g(x) の根として指定することで, 最小距離を制御する. 生成多項式 g(x) はそれらの最小多項式の最小公倍数で与えられる. 実用では2進系BCHがメモリ, フラッシュ, ストレージ, 低遅延通信の誤り訂正に広く使われ, 設計距離をパラメトリックに選べることが利点である.

## 入力例と出力例
例（概念）.
- n と原始元 α を定め, t=2, b=1 とする.
- 連続根 {α, α^2, α^3, α^4} の各最小多項式を取り, LCM を g(x) とする.
- メッセージ u に対し, 巡回符号として c(x)≡u(x)·g(x) mod (x^n−1) を出力する.

## アルゴリズム
本実装は、生成多項式の構成（最小多項式の LCM）と、巡回符号としての符号化を提供する。

手順は次の通りである。
- 与えられた連続根に対応する最小多項式群を集め、それらの最小公倍数を取って g(x) を作る。
- g(x) の次数 r を用いて k=n−r を決める。
- 情報語 u に対して多項式乗算 v=u·g を行い、v を x^n≡1 の下で長さ n に折り畳んで符号語 c を得る。

手順の詳説は以下のとおりである。
- 生成多項式の構成:
	- 基本体 F=GF(p) と拡大体 GF(p^m) を取り、原始元 α を一つ固定する。符号長 n は通常 n | (p^m−1) を満たす。
	- 設計距離 d=2t+1 と開始指数 b を与え、連続根の候補指数集合 S={b, b+1, ..., b+2t−1} を作る。
	- 各 s∈S について、p による冪閉包で生成されるサイクロトミー類 C_s={ s·p^ℓ mod n | ℓ≥0 } を求め、代表ごとに最小多項式 m_s(x)=∏_{j∈C_s} (x−α^j)（GF(p) 上）を得る。
	- 重複を除いた最小多項式群 {m_s} の LCM を取り g(x) を得る。g(x) は単項式で x^n−1 を割る。
- 符号化:
	- r=deg g、k=n−r とし、情報語 u(x) の係数配列（低次→高次）と g(x) の係数配列の畳み込み v=u*g を計算する（長さ k+r）。
	- v を x^n≡1 の同値で長さ n に折り畳む。具体的には c[t mod n]+=v[t] を全 t で行い、c を出力とする。

制約と注意.
- 連続根は互いに素なサイクロトミー類の和集合になる必要がある（重複は自動的に LCM で解消される）。
- n は α の位数を割る値に設定する必要がある。x^n−1 の因数でない多項式を g として選ぶことはできない。
- 本実装は符号化のみであり、標準的な系統符号化（x^{n−k}u を g で割って余りを付加する方式）や復号は実装外である。

計算量の目安.
- 最小多項式の構成は拡大体での演算に依存する。指数類の列挙と重複除去は O(d·log n) 程度、m_s の算出は体演算コストに比例する。
- 符号化は畳み込み O(k·r) と折り畳み O(n) である。

```text
# g = LCM(minimal_polys)
input: minimal_polys = [p1(x), p2(x), ...]
g = 1
for p in minimal_polys:
	g = lcm(g, p)
deg_g = degree(g)             # r
k = n - deg_g

# encode(u)
# u: length k, g: length r+1 (low->high)
v = zeros(k + r)
for i in 0..k-1:
	for j in 0..r:
		v[i+j] += u[i] * g[j]
c = zeros(n)
for t in 0..(k + r - 1):
	c[t % n] += v[t]          # x^n ≡ 1 で折り畳み
return c
```
