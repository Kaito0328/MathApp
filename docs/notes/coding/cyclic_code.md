# Cyclic code（coding/src/cyclic.rs）

## 背景知識
巡回符号は, 情報の並びをぐるっと回しても成立するように作った符号である. ある多項式 g(x) を「型」として用意し, 情報 u(x) にその型を掛け, 長さ n で一周するルール x^n≡1 に合わせて折り畳むだけで符号語が得られる. この構造はハードウェア実装やストリーミング処理に適し, 実用ではBCHやRSの下位構造, CRCなどの検出符号, ディスクや光学メディア, 通信フレームの誤り制御の基盤として用いられている.

より厳密には, 有限体 F 上の長さ n の環 F[x]/(x^n−1) におけるイデアル C=⟨g(x)⟩ として定義される. 生成多項式 g(x) はモニックで x^n−1 を割る. 冗長度 r=deg g, 次元 k=n−r である. 検査多項式 h(x)=(x^n−1)/g(x) を用いると, 多項式 c(x) が符号語であることは h(x) が c(x) を割ることと同値である. 実装では係数配列を低次→高次で保持し, 畳み込みと添字の折り畳みで c(x) を生成する.

## アルゴリズム
本実装が提供するのは非系統符号化のみである。情報語 u と生成多項式 g の積を取り、x^n≡1 の下で長さ n に折り畳む。

手順は次の通りである。
- まず u と g の畳み込み v を計算する（多項式乗算）。
- 次に v を長さ n に折り畳む。具体的には各次数 t の係数を c[t mod n] に足す（x^n≡1 の同値でまとめる）。
- 得られた長さ n の配列 c が符号語である。

入力は u（長さ k）と g（長さ r+1, 低次→高次）で n=k+r、出力は c（長さ n）である。

```text
v = zeros(k + r)
for i in 0..k-1:
    for j in 0..r:
        v[i+j] += u[i] * g[j]
c = zeros(n)
for t in 0..(k + r - 1):
    c[t % n] += v[t]
return c
```

制約と注意.
- g(x) はモニックで x^n−1 を割る必要がある。これにより C=⟨g(x)⟩ は環 F[x]/(x^n−1) のイデアルになり、巡回性を満たす。
- 本実装は非系統形である。系統形 c(x)=u(x)·x^{n−k}−(u(x)·x^{n−k} mod g(x)) を用いる場合は別実装が必要である。

計算量の目安.
- 畳み込み O(k·r)、折り畳み O(k+r)=O(n)。FFT などは不要なスケールである。
