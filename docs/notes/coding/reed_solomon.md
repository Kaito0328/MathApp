# Reed–Solomon code（coding/src/rs.rs）

## 背景知識
Reed–Solomon 符号は、有限体上の評価という極めて自然な操作に基づく誤り訂正符号である。メッセージ多項式 f(x) を相異なる点 α_0..α_{n-1} で評価して得た列が符号語になる。生成行列は G[i,j]=α_j^i の Vandermonde で表され、評価と線形代数が直結するのが特徴である。実用では、光ディスクや磁気ディスク、デジタル放送、衛星通信、QR コードなど、バースト誤りに強い符号として広く使われている。

## 入力例と出力例
例（概念、体は任意の有限体）。
- k=2、評価点 α=[a,b,c]（n=3）。
- メッセージ f=[f0,f1]（f(x)=f0+f1 x）。
- 出力は v=[f(a), f(b), f(c)] であり、行列表現では v=f·G、G=\begin{pmatrix}1&1&1\\a&b&c\end{pmatrix} である。

## アルゴリズム
本実装は、生成・符号化・簡易復号（RREF を用いた補間近似）を提供する。

手順は次の通りである。
- 生成: 評価点 α の列から Vandermonde 生成行列 G を作る（行 i, 列 j は α_j^i）。
- 符号化: メッセージ f と G を体上の行列積で掛けて v=f·G を得る。
- 簡易復号: α^i の表を用意し、A0 と A1 を構成して A=[A0 | diag(r)·A1] を作る。これを RREF 化し、最右列から q0,q1 を読み出す。多項式除算で f̂=q0/q1 を求め、先頭 k 係数を推定メッセージとする。

手順の詳説は以下のとおりである。
- 生成（new）:
  - 入力は次数上限 k と評価点 α_0..α_{n-1} である。n は評価点の個数である。
  - 生成行列 G は k×n の行列で、G[i,j]=α_j^i（i=0..k−1、j=0..n−1）と定義する。α_j^0=1 を用い、累乗は繰り返し乗算で蓄積する。
  - 併せて t=⌈(n−k)/2⌉ を保持する。これは理論上訂正できる誤り重量の上限である。
- 符号化（encode）:
  - メッセージは係数ベクトル f=(f_0,..,f_{k−1}) とみなし、各出力成分は v_j=∑_{i=0}^{k−1} f_i·α_j^i である。すなわち v=f·G（体上の行列積）で計算できる。
  - 出力は長さ n のベクトル v である。
- 簡易復号（decode, RREF による補間型）:
  - 目標は q0(x), q1(x) を見つけて f(x)=−q0(x)/q1(x) を復元することである。次数条件は deg q0 < n−t、deg q1 ≤ t である。
  - 未知係数を a_i（i=0..n−t−1）、b_i（i=0..t）と置くと、各評価点 α_j に対して
    ∑_{i=0}^{n−t−1} a_i·α_j^i + r_j·∑_{i=0}^{t} b_i·α_j^i = 0
    を満たす。これをすべての j=0..n−1 で並べると、A·x=0（同次）となる。
  - 行列の構成は A=[A0 | diag(r)·A1] で、A0 の列 i は (α_0^i,..,α_{n−1}^i)^T（i=0..n−t−1）、A1 の列 i は (α_0^i,..,α_{n−1}^i)^T（i=0..t）である。サイズは A0: n×(n−t)、A1: n×(t+1)、A: n×(n+1) である。
  - A に対して RREF を取り、スカラー倍の不定性を消すために q1 の最高次係数 b_t=1 に規格化する（最後の変数を 1 に固定するのと同値である）。このとき他の変数は最右列から読める。実装では RREF の結果の最右列から q0 の係数 a と q1 の係数 b（符号は式を満たすように反転）を抽出し、q1 は最高次係数を 1 に設定する。
  - 得られた q0, q1 に対して多項式除算を行い、f̂=−q0/q1 を計算する。係数ベクトルのうち先頭 k 成分を推定メッセージとして返す。

数理の要点は次の通りである。受信語 r に対し、未知係数を持つ多項式 q0(x), q1(x) を

- deg q0 < n−t、deg q1 ≤ t、かつ
- すべての評価点について q0(α_j) + r_j·q1(α_j) = 0（j=0..n−1）

を満たすように探す。この連立一次方程式は係数ベクトル [q0; q1] に関して同次であり、非自明解が期待される。誤り重量が t 以下で r_j = f(α_j) + e_j と書けるとき、誤り位置集合 E に対して q1(x) は誤り位置多項式に比例し、q0(x) = −f(x)·q1(x) が成り立つため、f(x) = −q0(x)/q1(x) を再構成できる。規格化として q1 の最高次係数を 1 に固定すると一意性が得られる（スカラー倍の不定性を除く）。

```text
# new(k, alphas)
input: k, alphas[0..n-1]
G = zero_matrix(k, n)
for i in 0..k-1:
  for j in 0..n-1:
    acc = 1
    repeat i times: acc = acc * alphas[j]
    G[i,j] = acc
return RS{ k, n, t=ceil((n-k)/2), alphas, G }

# encode(f)
# f: 1 x k, G: k x n
v = f * G   # 行列積（体上）
return v    # 1 x n

# decode(r)  簡易（補間型）
input: r (1 x n)
# 準備: α^i 表を用意
max_pow = max(k, n-t, t+1)
exp[j,i] = (alphas[j])^i for j=0..n-1, i=0..max_pow-1
A0 = exp[:, 0..(n-t-1)]      # n x (n-t)
A1 = exp[:, 0..t]            # n x (t+1)
A  = concat_cols(A0, diag(r) * A1)  # n x (n+1)
# 右辺0で RREF
Q, _ = RREF(A, zeros(n,1))
# 最右列から q0, q1 を抽出（実装依存の取り方で OK）
q0 = poly_from(Q[0..(n-t)-1, last_col])
q1 = poly_from(-Q[(n-t)..n-1, last_col]) with last coeff set to 1
fhat, _ = poly_div(q0, q1)
return coeffs(fhat)[0..k-1]
```

### 制約と失敗時の扱い
- 評価点 α_j はすべて相異なる必要がある（Vandermonde の列が一次独立であるため）。
- 復号は誤り重量が t = ⌊(n−k)/2⌋ 以下のときに一意復元が可能である。
- RREF で得た q1 の次数が t を超える、あるいは q1 が零に近い（全零）などの異常は復号失敗とみなすのが安全である。多項式除算の余りが大きい場合も失敗と扱える。

### 計算量の目安
- 生成（new）: O(k·n)。累乗は繰り返し乗算で累積すれば効率的である。
- 符号化（encode）: O(k·n)。
- 復号（decode）: 行列 A は n×(n+1) 規模で、単純な RREF は O(n^3) 程度である。GUI の教育用途では十分実用である。
