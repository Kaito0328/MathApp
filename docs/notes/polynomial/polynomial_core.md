# Polynomial（core）

## 背景知識
多項式を係数配列（低次→高次）で保持すると、加減乗は配列操作になり、除算・微分・積分・評価も機械的に実装できる。ゼロ多項式の次数は −1 と定義し、正規化で末尾の 0 を落とす。

## 入力例と出力例
- 入力: 係数配列 c=[c0, c1, ..., cn]。
- 出力: 多項式 p(x)=∑ c_i x^i。操作に応じて別の係数配列を返す。

## アルゴリズム
- 正規化: 末尾の 0 を削除し、全て 0 なら `deg=-1` とする。
- 除算 div_rem(a,b)
  - 前提: b≠0。a を r、商 q を 0 で初期化。最高次数の差 d=deg(r)−deg(b) が負になるまで繰り返す。
  - 係数比 s=r_lead/b_lead を求め、q[x^d]+=s、r から s·x^d·b を減算する。最後に正規化し (q,r) を返す。
- 乗算 mul_simple/mul_fft
  - simple: 二重ループで (i,j) に対し out[i+j]+=a[i]*b[j]。
  - fft: ゼロ埋め→FFT→点ごと積→逆 FFT→丸め→正規化。
- Horner 評価: `y = (((c_n x + c_{n-1}) x + ...) x + c_0)`。
- 微分・積分: 定義通り、係数を i 倍（微分）/ 1/(i+1) 倍（積分）してシフト。

実装詳細と注意:
- 正規化の閾値: 浮動小数では |c|<tol を 0 とみなして末尾削除する。
- 除算のスケーリング: 浮動小数では被除数/除数のスケールを合わせてから実施すると丸め誤差が減る。
- mul_fft のパディング: 畳み込み長 L=deg(a)+deg(b)+1 に対し N を2べきに切上げ、N ≥ L を満たす長さで零埋めする。逆FFT後は最も近い整数/既知の型へ丸める。
- Horner の安定化: x のスケーリングや Kahan 加算で丸め誤差を軽減できる。

### 計算量と制約
- mul_simple/div_rem は O(n·m)。mul_fft は O(N log N)（N はパディング長）。
- 体 F の逆元が必要な操作（除算・積分）では 0 で割らないように注意する。
